### 🤔 Recap and overview of what we did
Let's quickly recap what we had to do for deploying the template contract. First, we generated a bunch of boilerplate with Terrain using the command 
```
terrain new clicker-portal
```
And then to deploy, we just ran:
```
terrain deploy counter --signer test1
```

This seems pretty simple, and that's because of how awesome Terrain is! Behind the scenes, Terrain does all of these:

1. Builds the contract
2. Optimizes it
3. Generates the contract JSON schemas
4. Uploads the contract to LocalTerra
5. Instantiates the contract

I won't go into too much detail on these, I'll just run through each one briefly. You can find all the generated files in the `Learn-Terra/clicker-portal/contracts/counter` folder. 

**Building a contract**
What does building even mean? We write our smart contracts in Rust but the platform Terra contracts run on, CosmWasm, runs on WASM (WebAssembly) bytecode. So when we "build" our smart contract, we're compiling our Rust code into WASM bytecode so the blockchain can run it.

**Optimizing a contract**
Once we've got the WASM binary output, we need to make sure it's as small as possible to minimize fees and stay under the size limit for the blockchain. Read more [here](https://docs.terra.money/docs/develop/dapp/smart-contracts/write-smart-contract.html#optimizing-your-build).

**JSON schemas**
If you've worked with Solidity before, the JSON schemas here are just like contract ABIs (Application Binary Interfaces).

Our contract does a bunch of things. We know what these things are because we wrote it (not yet but we will lol). How do we tell our computer what these things are? We make something called *schemas*. A schema is just a formal "description" of what a contract does and how you're allowed to interact with it. For example, we can use schemas to prevent the wrong data types from being passed into functions. Instead of spamming the blockchain with invalid data, you'll be stopped at the application or wallet layer.

You can register which data structure schemas you want to auto-generate in the `examples/schema.rs` file. Read more [here](https://docs.terra.money/docs/develop/dapp/smart-contracts/write-smart-contract.html#schemas).

**Uploading the contract**
On Terra, uploading and "creating" a contract are two different events. First, you upload the contract's code. Then, you instantiate your copy of it. This way if someone else wants to deploy the same contract, they can just use the one that exists on the blockchain already.

**Instantiate the contract**
Once the code is on the blockchain, we call the instantiate message and optionally pass in a few parameters to create our instance of it. Think of this like calling the contract constructor.  

You can do each of these steps manually using something called `terrad`, but I recommend just sticking with Terrain. 

### 👶 A basic smart contract
Now we can get started with the fun stuff! To write our own contract, we'll use the counter contract template as it has all the boilerplate stuff we need. 

In the `clicker-portal/contracts` directory, run this command to create a contract called `clicker`:
```bash
# Desktop/Learn-Terra/clicker-portal/contracts
cargo generate --git https://github.com/InterWasm/cw-template.git --branch 0.16 --name clicker
cd clicker
```

With your favorite code editor (I like VS Code), open the `clicker-portal` folder so you can start writing! You should see a folder structure just like this:

```bash
Desktop/Learn-Terra/clicker-portal
├── frontend               # The front-end application.
├── contracts              # The contracts' source code.
|  ├── clicker             # The template contract
|  └── counter             # The contract we generated
├── lib                    # Predefined functions for task and console.
├── tasks                  # Predefined tasks.
├── config.terrain.json    # Config for connections and contract deployments.
├── keys.terrain.js        # Keys for signing transactions.
├── package-lock.json      # Generated by NPM for Node Modules
├── package.json           # Generated by NPM for Node Modules
└── refs.terrain.json      # Deployed code and contract references.
```

We want the `clicker` folder inside `contracts`. Open it up and you'll see a bunch of Rust project stuff. We don't care about any of it right now except the files in the `src` folder.
```
Desktop/Learn-Terra/clicker-portal/contracts/clicker
└── src
|  ├── contract.rs
|  ├── error.rs
|  ├── lib.rs
|  ├── msg.rs
|  ├── state.rs
```

All of these files combine to make a smart contract. Here's what each is for:

* `msg.rs`: Remember how I said that CosmWasm works with messages? This file is where we define the types of our messages and the information attached to them (but no logic). The definitions in this file are what are exposed to our front-end application. Think of this like the API schema (JSON schema is generated from it) of our contract.
* `state.rs`: This is where we define the storage types and the state of our contract. Think of it like the database schema.  
* `error.rs`: This is where we define custom errors!
* `lib.rs`: This contains wasm bindings, don't worry about this, we won't need to touch it.
* `contract.rs`: This is where everything comes together and we define the logic of our smart contract.
  
Alright, open `contract.rs` in your editor. Go ahead and delete everything in it! We're going to start with a clean slate. Here's what our baby contract looks like:

```rust
#[cfg(not(feature = "library"))]
use cosmwasm_std::entry_point;
use cosmwasm_std::{DepsMut, Env, MessageInfo, Response};
use cw2::set_contract_version;

use crate::error::ContractError;
use crate::msg::{InstantiateMsg};
use crate::state::{State, STATE};

// version info for migration info
const CONTRACT_NAME: &str = "crates.io:clicker";
const CONTRACT_VERSION: &str = env!("CARGO_PKG_VERSION");

#[cfg_attr(not(feature = "library"), entry_point)]
pub fn instantiate(
  deps: DepsMut,
  _env: Env,
  info: MessageInfo,
  msg: InstantiateMsg,
) -> Result<Response, ContractError> {
  Ok(Response::default())
}
```

A lot happening here so let's just step line-by-line. Again, if you don't know Rust — don't worry too much. I think you can pick this stuff up pretty quickly. You won't become a Rust Master like this, but, you can worry about that later :).

```rust
#[cfg(not(feature = "library"))]
use cosmwasm_std::entry_point;
use cosmwasm_std::{DepsMut, Env, MessageInfo, Response};
use cw2::set_contract_version;
```

We start with a [macro](http://web.mit.edu/rust-lang_v1.25/arch/amd64_ubuntu1404/share/doc/rust/html/book/first-edition/macros.html) - `#[cfg(not(feature = "library"))]`. These basically attach code to our module. This macro is for [conditional compilation](https://web.mit.edu/rust-lang_v1.25/arch/amd64_ubuntu1404/share/doc/rust/html/book/first-edition/conditional-compilation.html). Basically, it just says "only compile this code if the library feature isn't enabled". We'll be seeing this #[blah] syntax a few places. Right after, we have a bunch of `use` statements, these are just like `import` statements in Python/JavaScript or `#include` in C. We want to import in all the required blockchain stuff from CosmWasm. 

```rust
const CONTRACT_NAME: &str = "crates.io:clicker";
const CONTRACT_VERSION: &str = env!("CARGO_PKG_VERSION");
```

Rust constants! You've got the `const` keyword, the variable name, the type, and the value. Pretty straightforward. The `&` before the `str` type declaration means that the variable is a reference - it's read only and more efficient. `env!` is a macro which gets the value of an environment variable. Btw - semi-colons are **not** optional in Rust. If you forget them the compiler will yell at you lol.

```rust
#[cfg_attr(not(feature = "library"), entry_point)]
pub fn instantiate(
  deps: DepsMut,
  _env: Env,
  info: MessageInfo,
  msg: InstantiateMsg,
) -> Result<Response, ContractError> {
  Ok(Response::default())
}
```

And finally - the meat and potatoes (or rather the french fry) of our very tiny contract. Right now all our contract does is *start*. It has no functions you can call, no magic internet money it can generate.

The `instantiate` function is called only once - when the contract is first created. It takes in:
* `deps`: You'll see this for almost everywhere - it has the storage, API and [Querier](https://github.com/terra-money/terra-cosmwasm/blob/main/README.md) functions. This contains dependencies we need to access storage, etc.
*  `_env`: Blockchain environment variables like block and contract info. The `_` means you may not use it. Read more [here](https://stackoverflow.com/questions/48361537/why-do-underscore-prefixed-variables-exist).
*  `info`:  Message info like the sender, signature, and funds sent in. Tells you who sent the money and what they sent.
*  `msg`: The message and payload of the call. This is where you'd find function params. Tells you what the caller wants to do. 

These might seem overwhelming at first - don't worry. You just need to know what they're about, not how they work. You'll get used to them pretty quickly. 

```rust
Result<Response, ContractError> 
```
Next, we've defined the return types - either a `Response`, or a `ContractError` that we're importing from `error.rs`. 

```rust
    Ok(Response::default())
```
Finally, we've got the body of the contract. Right now, we're not doing anything, we're just saying "ok!" using a [standard result type](https://doc.rust-lang.org/std/result/).

Okay, we've got a whole lot of nothing right now. Let's see if it compiles. Navigate to inside your `clicker` contract folder and run `cargo build`.

```bash
# Desktop/Learn-Terra/clicker-portal/
cd contracts/clicker/
cargo build
```

After a few seconds, you'll see a bunch of warnings and this at the end:
```bash
warning: `clicker` (lib) generated 7 warnings
    Finished dev [unoptimized + debuginfo] target(s) in 1.27s
```

This is great! You just built your first contract. The Rust compiler is very helpful - it'll save you a bunch of trouble with the warning messages. Right now all of your warnings are just about unused variables and imports cause we're not doing anything with them lol. Your contract still works though, and we can deploy it to the blockchain if we want.

Next, we'll make our contract actually do something and learn to interact with it using the Terrain console.

### 👝 Store custom data in your contract
Think of the coolest number you know of. Is it an xkcd comic? Is it someone's birthday? Is it just Pi? We're going to store this number on ✨ the blockchain ✨ so everyone knows about it. Here's what our updated contract will look like for this, I left comments for the new stuff I added:

```rust
use cosmwasm_std::entry_point;
use cosmwasm_std::{DepsMut, Env, MessageInfo, Response};
use cw2::set_contract_version;

use crate::error::ContractError;
use crate::msg::{InstantiateMsg};
use crate::state::{State, STATE};

const CONTRACT_NAME: &str = "crates.io:clicker";
const CONTRACT_VERSION: &str = env!("CARGO_PKG_VERSION");

#[cfg_attr(not(feature = "library"), entry_point)]
pub fn instantiate(
  deps: DepsMut,
  _env: Env,
  info: MessageInfo,
  msg: InstantiateMsg,
) -> Result<Response, ContractError> {

  // We're storing stuff in a variable called "state" of type "State"
  let state = State {
    count: msg.count,
    owner: info.sender.clone(),
  };

  // We're setting the contract version using a helper function we imported
  set_contract_version(deps.storage, CONTRACT_NAME, CONTRACT_VERSION)?;
  // We're storing state in a special variable called "STATE"
  STATE.save(deps.storage, &state)?;

  // Sending a response back to the caller
  Ok(Response::new()
    .add_attribute("method", "instantiate")
    .add_attribute("owner", info.sender)
    .add_attribute("count", msg.count.to_string()))
}
```

The comments should give you an idea of what's happening. We're going to take the inputs of the transaction and store them in our contract. Just keep in mind that `state`, `State` and `STATE` are three different things lol. We'll rename these later so it isn't as confusing. Again, from the top:

```rust
let state = State {
    count: msg.count,
    owner: info.sender.clone(),
};
```
Pretty straightforward: we're creating a variable named `state` of type `State`. It needs two fields to be initialized: `count` and `owner`. The value of `count` is passed in as a parameter when the `instantiate` function is called and we use the sender's address for `owner`. `clone()` is important because we don't want to *give ownership* of the value to the `State` struct, we just want to create a copy of it.

```rust
// We're setting the contract version using a helper function we imported
set_contract_version(deps.storage, CONTRACT_NAME, CONTRACT_VERSION)?;
// We're storing state in a special variable called "STATE"
STATE.save(deps.storage, &state)?;
```
These are pretty self explanatory. I'll go over what `STATE` is later on, it's from the `state.rs` file. Something weird here is the `?` at the end of both. In Rust, `?` is used to propagate errors. If either of these statements fail for some reason, the error will be returned and the program will stop executing.

```rust
Ok(Response::new()
  .add_attribute("method", "instantiate")
  .add_attribute("owner", info.sender)
  .add_attribute("count", msg.count.to_string()))
```
Once our function has done everything it needs to, we send back an HTTP response to the transaction sender, sort of like a web server sending a 200 HTTP code. We add three attributes to the response - the method to confirm to the caller what they just did, and the values we set. These return values **need** to be strings! Don't try returning a raw array or custom struct.

Now if you run `cargo build` in your terminal again, all the warnings will be gone! Nice! Look at you. Getting rid of warnings in *Rust*. Fancy.

We can *write* data to our contract, but how about reading it? Check this out:

```rust
#[cfg_attr(not(feature = "library"), entry_point)]
pub fn query(deps: Deps, _env: Env, msg: QueryMsg) -> StdResult<Binary> {
  match msg {
      QueryMsg::GetCount {} => to_binary(&query_count(deps)?),
  }
}

fn query_count(deps: Deps) -> StdResult<CountResponse> {
  let state = STATE.load(deps.storage)?;
  Ok(CountResponse { count: state.count })
}
```
Looks complicated lol.

Add this to the bottom of your contract right after where the `instantiate` function ends (errors are expected for now). 

We want to read data from our contract. CosmWasm has a special message type for this: `query`. First, we define the public `query` function. It doesn't actually look up any data, it's like a traffic controller for all the incoming query requests and the corresponding functions for them. 

We already know the arguments it's taking in, the only difference is `Deps` instead of `DepsMut` (short for mutable) since we don't want to change anything in storage. The return is wrapped in `StdResult`, which is just a standard type CosmWasm gives us that allows errors to be sent. `binary` is a bit funny. For now, all you need to know is that once we have the data we want, we need to convert it to binary. You can read more about why we do this [here](https://docs.cosmwasm.com/docs/1.0/architecture/serialization).

```rust
  match msg {
      QueryMsg::GetCount {} => to_binary(&query_count(deps)?),
  }
```
The next bit is a `match` for the value of `msg`. `match` is a lot like a switch statement or a select - it checks the value of `msg`, if it matches the case, it runs the code. Rust syntax is pretty clean here - the type of `QueryMsg` is an [enumerable](https://doc.rust-lang.org/rust-by-example/custom_types/enum.html), so we can just list all the options and the first match gets executed. In this case the action is to call the `query_count` function. The value returned by it is then converted to binary and returned.

```rust
fn query_count(deps: Deps) -> StdResult<CountResponse> {
    let state = STATE.load(deps.storage)?;
    Ok(CountResponse { count: state.count })
}
```
Finally, we have the actual read function itself. All this function does is fetch the state from storage into the `CountResponse` struct and send it back. Note the lack of a semicolon `;` for `Ok` - this means that the whole `Ok` object is returned. 

You're probably wondering where `CountResponse` and `GetCount` are coming from. They're defined in the `msg.rs` file! We'll get there soon!

To get rid of the errors, you just need to import the new stuff we're using. At the top of your `contract.rs` file, update the `use` statements to this, I've added comments for the new stuff:
```rust
use cosmwasm_std::entry_point;
// We're adding to_binary, Binary, Deps and StdResult 
use cosmwasm_std::{to_binary, Binary, Deps, DepsMut, Env, MessageInfo, Response, StdResult};
use cw2::set_contract_version;

use crate::error::ContractError;
// We're adding InstantiateMsg and QueryMsg
use crate::msg::{CountResponse, InstantiateMsg, QueryMsg};
use crate::state::{State, STATE};
```

If you run `cargo build` now all your errors should be gone. Let's deploy!!!

Navigate back to your `clicker-portal` directory and run the deploy command:
```
# Desktop/Learn-Terra/clicker-portal/contracts/clicker
cd ../..
terrain deploy clicker --signer test1
```
You should see something like this at the bottom of the output:
```
- type: wasm
  attributes:
    - key: contract_address
      value: terra12je8p24cskflgc3xqwxdu2zrnlj449aslmwgej
    - key: method
      value: instantiate
    - key: owner
      value: terra1x46rqay4d3cssq8gxxvqz8xt6nwlz4td20k38v
    - key: count
      value: "0"
```

Your contract was deployed and instantiated! Let's interact with it:
```
terrain console
await lib.getCount()
```

WOOOHOOO! We just read a number from our contract!

**Recap!**
Let's recap what we did:
1. We took our baby contract that did nothing and made it take a message when it's instantiated
2. We're storing the value passed in that message on blockchain storage
3. We made a `query` function that matches contract functions to query requests and returns their data
4. We made a `query_count` function that reads the data from the blockchain storage

NICE. That's a lot of doing. You're doing the things developers do all day. They read docs, understand code and then implement it to do whatever they need. You're doing blockchain developer stuff right now. I'm proud of you.

We've been working just in `contract.rs` all this time. Now it's time to explore the other files a little bit and see how they connect to each other. 

The weird part of our "number" is that it's not really *ours*. We just used the `count` variable from the counter contract. No more! Let's make it our own. 

We're going to rename our number from `count` to whatever we want. We'll also rename everything else. It's super easy, here's what you'll need to do.

In your `state.rs` file, change the name of the `count` variable under the `State` struct to something else. Whatever the name of your favorite number is.
```rust
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
pub struct State {
  // Change `count` to whatever you want
  // pub count: i32,
  pub speed: i32,
  pub owner: Addr,
}
```

I'm going for `speed` cause I wanna store the speed of light lol. We're progressing at lightspeed after all :) **Don't just blindly copy me here.** You should choose something of your own! **This is important.** If you just copy/paste my code, you won't understand how the `msg.rs`, the `state.rs` and `contract.rs` files work together. 

Next, in `msg.rs`, I'm gonna change all mentions of `count` to `speed`, including struct names. I've left comments for the things I changed:
```rust
use schemars::JsonSchema;
use serde::{Deserialize, Serialize};

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
pub struct InstantiateMsg {
  pub speed: i32, // Changed from count to speed
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum ExecuteMsg {
  Increment {},
  Reset { speed: i32 }, // Changed from count to speed
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum QueryMsg {
  // GetSpeed returns the speed of light as a json-encoded number
  GetSpeed {}, // Changed from GetCount to GetSpeed
}

// We define a custom struct for each query response
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
pub struct SpeedResponse { // Changed from CountResponse to SpeedResponse
  pub speed: i32, // Changed from count to speed
}
```

Finally, we do the same for our `contract.rs` file.
```rust
#[cfg(not(feature = "library"))]
use cosmwasm_std::entry_point;
use cosmwasm_std::{to_binary, Binary, Deps, DepsMut, Env, MessageInfo, Response, StdResult};
use cw2::set_contract_version;

use crate::error::ContractError;
use crate::msg::{SpeedResponse, InstantiateMsg, QueryMsg};
use crate::state::{State, STATE};

// version info for migration info
const CONTRACT_NAME: &str = "crates.io:clicker";
const CONTRACT_VERSION: &str = env!("CARGO_PKG_VERSION");

#[cfg_attr(not(feature = "library"), entry_point)]
pub fn instantiate(
  deps: DepsMut,
  _env: Env,
  info: MessageInfo,
  msg: InstantiateMsg,
) -> Result<Response, ContractError> {

  let state = State {
    speed: msg.speed,
    owner: info.sender.clone(),
  };

  set_contract_version(deps.storage, CONTRACT_NAME, CONTRACT_VERSION)?;
  STATE.save(deps.storage, &state)?;

  Ok(Response::new()
    .add_attribute("method", "instantiate")
    .add_attribute("owner", info.sender)
    .add_attribute("speed", msg.speed.to_string()))
}

#[cfg_attr(not(feature = "library"), entry_point)]
pub fn query(deps: Deps, _env: Env, msg: QueryMsg) -> StdResult<Binary> {
    match msg {
        QueryMsg::GetSpeed {} => to_binary(&query_speed(deps)?),
    }
}

fn query_speed(deps: Deps) -> StdResult<SpeedResponse> {
    let state = STATE.load(deps.storage)?;
    Ok(SpeedResponse { speed: state.speed })
}
```

If you didn't mess up the `CTRL`+`F` rename, `cargo build` in the `clicker` folder won't give you any errors. 

Before we move on to interacting with our contract, I wanna go over what `state.rs` and `msg.rs` do a bit more. 

**`state.rs`**
The way CosmWasm smart contracts persist state is through native LevelDB, a bytes-based key-value store. To be able to do this, we assign unique keys to data that can be indexed and later retrieved. You can think of the things in here like the database schema. If you want to store any data on chain, you need to declare the variable names (keys) and types in here.

**`msg.rs`**
We've got this fancy Rust contract that can do all sorts of on-chain computation and store defined things permanently. If we want to interact with it to get data out of it or to call functions, we need to comply to a defined interface. Just like how you have API docs that tell you which functions you can call and which data types they take in and return, `msg.rs` does the same for smart contracts.


Cool, we've truly made the contract our own. Now let's set what number we're storing in it when it's started.

### 🤖 Interact with our baby contract
When we run the `terrain deploy clicker --signer test1` command, it uploads and instantiates our contract. How does it know which parameters to pass into the `instantiate` function? For the counter contract, these are already defined in the boilerplate code. If you try to deploy after renaming your variables, you'll get an error. Try it:
```
# Desktop/Learn-Terra/clicker-portal/contracts/clicker
cd ../..
terrain deploy clicker --signer test1
```
Here's what I see after a bunch of loading:
```
instantiating contract with code id: 11... !
    Error: Request failed with status code 400
    Response: failed to execute message; message index: 0: Error parsing into type clicker::msg::InstantiateMsg: missing field `speed`: instantiate wasm contract failed: invalid request
```

Lets fix this! Head over to the `config.terrain.json` file in your `clicker-portal` folder.
```json
{
  "_global": {
    "_base": {
      "store": {
        "fee": {
          "gasLimit": 2000000,
          "amount": {
            "uluna": 1000000
          }
        }
      },
      "instantiation": {
        "fee": {
          "gasLimit": 2000000,
          "amount": {
            "uluna": 1000000
          }
        },
        "instantiateMsg": {
          "speed": 299792458
        }
      }
    }
  },
```
**Note: This is NOT the entire file, don't copy paste!**

You'll see the `count` under `instantiateMsg`! I've changed mine to `speed` and updated the value. Now we're good to deploy again! 

```
# Desktop/Learn-Terra/clicker-portal/
terrain deploy clicker --signer test1
```
This will deploy fine. But when you try to get your awesome new number using the Terrain console, you'll get another error! This is because everything Terrain does needs to be configured, it can't magically just figure out how to interact with contracts (yet). Terrain doesn't know what to do when we run `lib.getSpeed`. 

Open the `index.js` file in the `Learn-Terra/clicker-portal/lib` folder so we can add our new `getSpeed` function. Update it to this:
```js
// Desktop/Learn-Terra/clicker-portal/lib/index.js
module.exports = ({ wallets, refs, config, client }) => ({
  getCount: () => client.query("counter", { get_count: {} }),
  increment: (signer = wallets.validator) =>
    client.execute(signer, "counter", { increment: {} }),

  // This is what we're adding. "clicker" is the contract we want to interact with, "getSpeed" is the function.
  getSpeed: () => client.query("clicker", { get_speed: {} }),
});
```

Now if you run `terrain console` and then try `await lib.getSpeed();`, you'll see your number!
```
terrain > await lib.getSpeed();
{ speed: 299792458 }
```

Nice, that wasn't too hard. You now know everything you need to do to upgrade your contract. Quick recap:
* `lib/index.js` is where we define our terrain functions.
* `config.terrain.json` is where we define our instantiate message params.
* `state.rs`, `msg.rs` and `contract.rs` are the core parts of the contract.
* We can interact with the contract using `terrain console` and `await lib.functionName();`

I've got a bonus challenge for you. Change the data type of `speed`. It's a number right now, maybe try a string? You can also just add another variable next to it. You'll need to define the type in `state.rs`, the functions and return types in `msg.rs` and update the instantiate message in `contract.rs`. Good luck!


### 🚨 Progress Report
*Please do this else Raza will be sad :(*

Post a screenshot of your terminal showing your awesome number in the Terrain console in #progress!

Epic work so far :).
