## ‚òéÔ∏è¬†Call your candy machine from your web app

We finally made it. Let's take a little recap of what we have done so far. We've:

1. Set up our web app.
2. Built a connect to wallet feature
3. Set up our candy machine, uploaded our NFTs, and deployed it all to devnet. 

Take a moment to give yourself all the claps üëè. You are now part of an elite crew of individuals who know how to do this. There are less than 20,000 developers on Solana right now. Use your power wisely, young warrior.

So, whats next? Well, now it's time to setup our web app to let users actually interact with our candy machine. We'll need to somehow call our candy machine from our web app. This will be very much like calling an API that lives on a server, but, we'll actually be calling our on-chain candy machine.

Before we get started, you'll notice under `components/CandyMachine/index.js` that there is a ton of boilerplate code. This is part of Metaplex's frontend library.

I **won't** be going into deep detail on the *all* the contents of `CandyMachine/index.js`. I want you to do that yourself.

Some of the stuff in this file is pretty advanced, but explore it and mess around with it as you please. The best way to learn this stuff is just by reading the code yourself and playing around with it.

But, don't worry too much about exploring yet. Let's get shit working first lol.

### üå≤¬†**Setup `.env` properties**

Remember those public keys I asked you to keep handy? Well, it's finally time to use them! Before we get started here - **if you are committing your source code to something like Github, make sure you DO NOT commit your `.env` file**. This is common practice for any web app you make. Those files usually contain sensitive information so be **careful**.

Okay, to get started just create a `.env.local` file at the root of your web app's `app` folder (i.e `nft-drop-starter-project/app/.env`). This is where we will go ahead and store our keys. Add the following to your `.env.local` to start:

```plaintext
NEXT_PUBLIC_CANDY_MACHINE_ID=YOUR_CANDY_MACHINE_ID
NEXT_PUBLIC_SOLANA_NETWORK=devnet
NEXT_PUBLIC_SOLANA_RPC_HOST=https://metaplex.devnet.rpcpool.com/
```

Let's go one by one (note: **no** quotation symbols needed here).

**Note:** `cache.json` can be found at the root of your folder after running the Metaplex command in previous steps. To learn more about using environment variables in Next.js, you can read [here](https://nextjs.org/docs/basic-features/environment-variables)


`NEXT_PUBLIC_CANDY_MACHINE_ID` - This is the address I asked you to keep handy. If you've lost it, it can be found in the `cache.json` JSON file, look for the value associated with the `candyMachine` key. 

`NEXT_PUBLIC_SOLANA_NETWORK` - Set this to `devnet` as this is just the network in which we are accessing our candy machine from

`NEXT_PUBLIC_SOLANA_RPC_HOST` - This is pretty much the same as above. Since we are accessing out Candy Machine on devnet we need to point the RPC to that devnet link which is `https://explorer-api.devnet.solana.com`

Cool, this all looks setup. Our web app needs all these variables so it knows stuff like: what candy machine to talk to, what network to mint on, etc.

When you change `.env.local`, I've found I need to actually kill my React process in Terminal and do `npm run start` again. So, be sure to do that whenever you change the `.env.local` file.

One more random thing to do before moving on. In Phantom go to Settings ‚Üí Change Network ‚Üí and choose "Devnet". Our candy machine lives on devnet so we need to make sure our wallet is on devnet as well!

![Untitled](https://i.imgur.com/wzxriNg.png)

### ü§¨  A note on changing your NFTs
Let's say you don't like the NFT collection you used for testing and got a better idea. You need to be careful here! Whenever you change your collection, you need to follow the same steps from earlier to deploy the NFTs.

1.  Delete the `cache.json` file that was generated by the Metaplex CLI's candy machine commands.
2. Change up your NFT files to be whatever you want!
3. Run Metaplex's `upload` command via the CLI to upload the NFTs and create a new candy machine.
4. Run Metaplex's `verify` command via the CLI to make sure the NFTs were uploaded and the candy machine was properly configured.
5. Update your `.env.local` file with the new address.

If you mess up even one of these steps, everything will break. So, watch out.


### üìû¬†Make a call to your candy machine

The first thing we're going to do is grab our candy machine's metadata. This metadata gives us some cool information such as the drop date, how many items have been minted, and how many items are available to mint.

It's also good to start with this because if we can grab the metadata then that means we set up our candy machine properly :).

Head over to `app/components/CandyMachine/index.js`.

Start by importing `useEffect` and setting up an `useEffect` that calls a function named `getCandyMachineState` which we'll be setting up.

```jsx
import React, { useEffect } from 'react';

...

const CandyMachine = ({ walletAddress }) => {

  ...
  
  useEffect(() => {
    getCandyMachineState();
  }, []);	
}
```

Before we get into the logic of `getCandyMachineState` we actually need to setup one other function called `getProvider` .

Essentially, this creates a new `AnchorProvider` object. The **provider** is how our web app talks to the Solana blockchain ‚Äî it's gives our client a connection to Solana + our wallet credentials so we can talk to programs on Solana.

Go ahead and add the  `getProvider` under wherever you put your `useEffect`.

```jsx
const getProvider = () => {
  const rpcHost = process.env.NEXT_PUBLIC_SOLANA_RPC_HOST;
  // Create a new connection object
  const connection = new Connection(rpcHost);
  
  // Create a new Solana provider object
  const provider = new AnchorProvider(
    connection,
    window.solana,
    opts.preflightCommitment
  );

  return provider;
};
```

Okay, back to `getCandyMachineState`. Make it somewhere under `getProvider`. Here's how it looks:

```jsx
// Declare getCandyMachineState as an async method
const getCandyMachineState = async () => {
  const provider = getProvider();
  
  // Get metadata about your deployed candy machine program
  const idl = await Program.fetchIdl(candyMachineProgram, provider);

  // Create a program that you can call
  const program = new Program(idl, candyMachineProgram, provider);

  // Fetch the metadata from your candy machine
  const candyMachine = await program.account.candyMachine.fetch(
    process.env.NEXT_PUBLIC_CANDY_MACHINE_ID
  );
  
  // Parse out all our metadata and log it out
  const itemsAvailable = candyMachine.data.itemsAvailable.toNumber();
  const itemsRedeemed = candyMachine.itemsRedeemed.toNumber();
  const itemsRemaining = itemsAvailable - itemsRedeemed;
  const goLiveData = candyMachine.data.goLiveDate.toNumber();
  const presale =
    candyMachine.data.whitelistMintSettings &&
    candyMachine.data.whitelistMintSettings.presale &&
    (!candyMachine.data.goLiveDate ||
      candyMachine.data.goLiveDate.toNumber() > new Date().getTime() / 1000);
  
  // We will be using this later in our UI so let's generate this now
  const goLiveDateTimeString = `${new Date(
    goLiveData * 1000
  ).toGMTString()}`

  console.log({
    itemsAvailable,
    itemsRedeemed,
    itemsRemaining,
    goLiveData,
    goLiveDateTimeString,
    presale,
  });
};
```

Alright ‚Äî a lot happening here, let's go over it.

```jsx
// Get metadata about your deployed candy machine program
const idl = await Program.fetchIdl(candyMachineProgram, provider);

// Create a program that you can call
const program = new Program(idl, candyMachineProgram, provider);
```

In order for us to talk to our candy machine, we'll need two things - **the `IDL` and a `Program` object**. The `IDL` has info our web app needs around how to interact w/ the candy machine. The `Program` is an object that we can use to actually **directly interact** with the candy machine.

You know how you create a `DB` connection in web2? Well ‚Äî here we're doing something similar lol. But, we're creating a connection to Solana.

At the end of the day, our candy machine is just a Solana program that lives on Metaplex! This means we can interact with it exactly like we would with any program that lives on Solana.

Once we create our `Program` object, we fetch it's metadata based on our candy machine id.

This line calls the fetch method on our candy machine program and returns `itemsAvailable` , `itemsRedeemed` , `itemsRemaining` , and `goLiveDate`.

```jsx
// Fetch the metadata from your candy machine
const candyMachine = await program.account.candyMachine.fetch(
  process.env.NEXT_PUBLIC_CANDY_MACHINE_ID
);

// Parse out all our metadata and log it out
const itemsAvailable = candyMachine.data.itemsAvailable.toNumber();
const itemsRedeemed = candyMachine.itemsRedeemed.toNumber();
const itemsRemaining = itemsAvailable - itemsRedeemed;
const goLiveData = candyMachine.data.goLiveDate.toNumber();
const presale =
  candyMachine.data.whitelistMintSettings &&
  candyMachine.data.whitelistMintSettings.presale &&
  (!candyMachine.data.goLiveDate ||
    candyMachine.data.goLiveDate.toNumber() > new Date().getTime() / 1000);
```

When we do `fetch` here, we're **actually hitting the Solana Devnet** to retrieve this data. It's looks a lot like we're hitting an API, but, we're actually hitting the blockchain!

### üß†¬†**Render the CandyMachine component.**

Let's actually render our `CandyMachine` component. If you scroll all the way to bottom of the `CandyMachine` component you'll see that we render a bunch of stuff under `return`. Let's show it!

Head to `app/pages/index.js` and import `CandyMachine`.

```jsx
import React from "react";
import dynamic from "next/dynamic";
import CandyMachine from "../components/CandyMachine";
import { useWallet } from "@solana/wallet-adapter-react";
```

From there, we just want to render `CandyMachine` if we have a user's wallet address in the state.

```jsx
return (
    <div className="App">
        <div className="container">
            <div className="header-container">
                <p className="header">üç≠ Candy Drop</p>
                <p className="sub-text">NFT drop machine with fair mint</p>
                {/* Render your connect to wallet button right here */}
                {wallet.publicKey ? <CandyMachine walletAddress={wallet} /> : renderNotConnectedContainer()}
            </div>
            <div className="footer-container">
                <img alt="Twitter Logo" className="twitter-logo" src="twitter-logo.svg" />
                <a className="footer-text" href={TWITTER_LINK} target="_blank" rel="noreferrer">{`built on @${TWITTER_HANDLE}`}</a>
            </div>
        </div>
    </div>
);
```

Notice how we pass in `wallet` to `CandyMachine` :).

### üç™¬†Render the retrieved data

Okay! Now, we shouldn't have any more errors and our `useEffect` in `CandyMachine` should fire as soon as we refresh our page.

Go ahead and refresh your page and you should see a little something like this in your console:

![Untitled](https://i.imgur.com/Z6ogT3P.png)

You literally just fetched data from the Solana Devnet. If you haven't celebrated, my god please do it now. This is HUGE. You are well on your way to becoming a web3 legend ü§ò.

*Note: Your `goLiveDateTimeString` might look different. If you want to render the data in a person's local timezone, just change `goLiveDateTimeString` in `getCandyMachineState` to:*

```jsx
const goLiveDateTimeString = `${new Date(
  goLiveData * 1000
).toLocaleDateString()} @ ${new Date(
  goLiveData * 1000
).toLocaleTimeString()}`;
```

*Up to you if you wanna do this.*

If you go to your site, you'll see some stuff is already rendered but we're not rendering any of the actual data. Let's do that. *BTW ‚Äî the design isn't very nice right now, but, you can fix that :).*

So to show the data, let's hold our candy machine stats in a state variable. Go ahead and import `useState` in your `CandyMachine` component at `app/components/CandyMachine/index.js` then go and add the follow code:

```jsx
// Import useState
import React, { useEffect, useState } from 'react';

...

const CandyMachine({walletAddress}) => {
  // Add state property inside your component like this
  const [candyMachine, setCandyMachine] = useState(null);

  ...

  const getCandyMachineState = async () => { 
    const provider = getProvider();
    const idl = await Program.fetchIdl(candyMachineProgram, provider);
    const program = new Program(idl, candyMachineProgram, provider);
    const candyMachine = await program.account.candyMachine.fetch(
      process.env.NEXT_PUBLIC_CANDY_MACHINE_ID
    );
    
    const itemsAvailable = candyMachine.data.itemsAvailable.toNumber();
    const itemsRedeemed = candyMachine.itemsRedeemed.toNumber();
    const itemsRemaining = itemsAvailable - itemsRedeemed;
    const goLiveData = candyMachine.data.goLiveDate.toNumber();
    const presale =
      candyMachine.data.whitelistMintSettings &&
      candyMachine.data.whitelistMintSettings.presale &&
      (!candyMachine.data.goLiveDate ||
        candyMachine.data.goLiveDate.toNumber() > new Date().getTime() / 1000);
  
    const goLiveDateTimeString = `${new Date(
      goLiveData * 1000
    ).toGMTString()}`
  
    // Add this data to your state to render
    setCandyMachine({
      id: process.env.NEXT_PUBLIC_CANDY_MACHINE_ID,
      program,
      state: {
        itemsAvailable,
        itemsRedeemed,
        itemsRemaining,
        goLiveData,
        goLiveDateTimeString,
        isSoldOut: itemsRemaining === 0,
        isActive:
          (presale ||
            candyMachine.data.goLiveDate.toNumber() < new Date().getTime() / 1000) &&
          (candyMachine.endSettings
            ? candyMachine.endSettings.endSettingType.date
              ? candyMachine.endSettings.number.toNumber() > new Date().getTime() / 1000
              : itemsRedeemed < candyMachine.endSettings.number.toNumber()
            : true),
        isPresale: presale,
        goLiveDate: candyMachine.data.goLiveDate,
        treasury: candyMachine.wallet,
        tokenMint: candyMachine.tokenMint,
        gatekeeper: candyMachine.data.gatekeeper,
        endSettings: candyMachine.data.endSettings,
        whitelistMintSettings: candyMachine.data.whitelistMintSettings,
        hiddenSettings: candyMachine.data.hiddenSettings,
        price: candyMachine.data.price,
      },
    });
  
    console.log({
      itemsAvailable,
      itemsRedeemed,
      itemsRemaining,
      goLiveData,
      goLiveDateTimeString,
    });
  };
}
```

All we did was create a state variable and then make a call to `setCandyMachine` to set the data.

With that, we can easily render some cool pieces of data here. Go ahead and add this UI code to your render function:

```jsx
return (
  // Only show this if machineStats is available
  candyMachine && (
    <div className="machine-container">
      <p>{`Drop Date: ${candyMachine.state.goLiveDateTimeString}`}</p>
      <p>{`Items Minted: ${candyMachine.state.itemsRedeemed} / ${candyMachine.state.itemsAvailable}`}</p>
      <button className="cta-button mint-button" onClick={null}>
          Mint NFT
      </button>
    </div>
  )
);
```

It's that simple! You should see all the data nicely rendered on your web app now.

I provided a `CandyMachine.css` file that includes some base styles for you. When you are ready to make some changes, head over there and add whatever CSS you want to make it your own. Even if you're lazy, just change some colors around. Make this your own. Don't just follow me lol. 

You'll notice you have a fancy looking Mint NFT button, but when you click it, it does nothing üòî.

Don't worry! In the next section we are going to be building out the logic for this button and setting it up to mint our very first NFT.

### üö® Progress Report

*Please do this else Farza will be sad :(*

In `#progress` drop a screenshot of your web app showing off how it renders data it retrieves from your candy machine!
